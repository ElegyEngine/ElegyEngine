// SPDX-FileCopyrightText: 2022-present Elegy Engine contributors
// SPDX-License-Identifier: MIT

using Elegy.Common.Assets.MeshData;
using Elegy.Common.Maths;

namespace Elegy.Common.Assets.ElegyMapData
{
	/// <summary>
	/// An ELF render surface is concrete render data that describes
	/// a little part of world geometry. It is not necessarily a
	/// single face or a few coplanar faces, but rather a mesh consisting
	/// of all faces belonging to one octree leaf, where the faces share the same material.
	/// </summary>
	public class RenderSurface
	{
		/// <summary>
		/// AABB of this render surface.
		/// </summary>
		public Box3 BoundingBox { get; set; } = new();
		/// <summary>
		/// Position buffer.
		/// </summary>
		public List<Vector3> Positions { get; set; } = new();
		/// <summary>
		/// Normals buffer. Tangents and bitangents
		/// are built from normals and UVs.
		/// </summary>
		public List<Vector3> Normals { get; set; } = new();
		/// <summary>
		/// UV buffer.
		/// </summary>
		public List<Vector2> Uvs { get; set; } = new();
		/// <summary>
		/// Secondary UV buffer for lightmaps.
		/// </summary>
		public List<Vector2> LightmapUvs { get; set; } = new();
		/// <summary>
		/// Colour buffer.
		/// </summary>
		public List<Vector4> Colours { get; set; } = new();
		/// <summary>
		/// Index buffer.
		/// </summary>
		public List<int> Indices { get; set; } = new();
		/// <summary>
		/// Actual number of vertices.
		/// </summary>
		public int VertexCount { get; set; } = 0;

		/// <summary> Adds a new vertex to the surface. </summary>
		public void AddVertex( Vector3 position, Vector3 normal, Vector2 uv, Vector2 lightmapUv, Vector4 colour )
		{
			VertexCount++;
			BoundingBox = BoundingBox.Expand( position );

			Positions.Add( position );
			Normals.Add( normal );
			Uvs.Add( uv );
			LightmapUvs.Add( lightmapUv );
			Colours.Add( colour );
		}

		/// <summary> Adds vertex indices to form a new triangle. </summary>
		public void AddTriangle( int a, int b, int c )
		{
			Indices.AddRange( [a, b, c] );
		}

		/// <summary>
		/// The name of the material associated with this surface.
		/// Multimaterials could perhaps be autogenerated from a collection
		/// of surfaces with fundamentally similar materials.
		/// </summary>
		public string Material { get; set; } = string.Empty;
		/// <summary>
		/// Lightmap texture name. It's up to the engine to autogenerate
		/// materials for these lightmaps.
		/// </summary>
		public string LightmapTexture { get; set; } = string.Empty;

		/// <summary>
		/// Converts this into an Elegy render mesh.
		/// </summary>
		public Mesh ToMesh()
			=> new()
			{
				Positions = Positions.ToArray(),
				Normals = Normals.ToArray(),
				Uv0 = Uvs.ToArray(),
				Uv1 = LightmapUvs.ToArray(),
				Color0 = Colours.Select( v => (Vector4B)v ).ToArray(),
				Indices = Indices.Select( i => (uint)i ).ToArray(),
				MaterialName = Material
			};
	}
}
