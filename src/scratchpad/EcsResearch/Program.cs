// SPDX-FileCopyrightText: 2024-present Elegy Engine contributors
// SPDX-License-Identifier: MIT

using fennecs;
using System.Diagnostics;
using System.Numerics;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;

namespace EcsResearch
{
	#region Internal stuff
	public class InputAttribute : Attribute
	{
	}

	[AttributeUsage( AttributeTargets.Struct, AllowMultiple = true )]
	public abstract class BaseRequiresAttribute : Attribute
	{
		public abstract Type ComponentType { get; }
	}
	
	public class RequiresAttribute<T> : BaseRequiresAttribute
		where T: struct
	{
		public override Type ComponentType => typeof( T );
	}

	[AttributeUsage( AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false )]
	public class MapComponentAttribute : Attribute
	{

	}
	#endregion

	#region Game system stuff
	public static partial class ComponentRegistry
	{
		/// <summary>
		/// This gets autogenerated by EcsResearch.Generators.
		/// </summary>
		public static partial bool ParseComponentKeyvalue( Entity entity, ReadOnlySpan<char> key, string value );
	}

	// Entity events
	public delegate void OnSpawnFn( GameEntity entity );
	public delegate void OnUseFn( GameEntity entity, GameEntity user );
	public delegate void OnDamageFn( GameEntity entity, GameEntity attacker, GameEntity inflictor, float damageValue );

	// Physics events
	public delegate void OnCollideStartFn( GameEntity entity, GameEntity collider );
	public delegate void OnCollideHoldFn( GameEntity entity, GameEntity collider );
	public delegate void OnCollideStopFn( GameEntity entity, GameEntity collider );
	public delegate void OnTriggerStartFn( GameEntity entity, GameEntity collider );
	public delegate void OnTriggerHoldFn( GameEntity entity, GameEntity collider );
	public delegate void OnTriggerStopFn( GameEntity entity, GameEntity collider );

	public class GameEntity
	{
		public GameEntity( World world, Dictionary<string, string>? data )
		{
			EcsEntity = world.Spawn()
				.Add<AudioSource>()
				.Add<Transform>()
				.Add( this );

			if ( data is null )
			{
				return;
			}

			foreach ( var pair in data )
			{
				switch ( pair.Key )
				{
					case "classname": break;
					case "targetname": Name = pair.Value; break;
					case "origin": Transform.Position = Vector3.Zero; break;
					case "angles": Transform.Orientation = Quaternion.Identity; break;
					default: ComponentRegistry.ParseComponentKeyvalue( EcsEntity, pair.Key, pair.Value ); break;
				}
			}
		}

		public Entity EcsEntity { get; set; }

		public string Name { get; set; }

		public event OnSpawnFn? OnSpawn;
		public event OnUseFn? OnUse;
		public event OnDamageFn? OnDamage;
		public event OnCollideStartFn? OnCollideStart;
		public event OnCollideHoldFn? OnCollideHold;
		public event OnCollideStopFn? OnCollideStop;
		public event OnTriggerStartFn? OnTriggerStart;
		public event OnTriggerHoldFn? OnTriggerHold;
		public event OnTriggerStopFn? OnTriggerStop;

		public ref AudioSource AudioSource => ref EcsEntity.Ref<AudioSource>();
		public ref Transform Transform => ref EcsEntity.Ref<Transform>();

		public void FireOutputs( string name )
		{
			Console.WriteLine( $"FireOutputs: {name}" );
		}
	}
	#endregion

	public enum AudioChannel
	{
		Dynamic,
		Ambient1,
		Ambient2,
		Ambient3,
		Ambient4,
		Body1,
		Body2,
		Body3,
		Body4,
		Item1,
		Item2,
		Item3,
		Item4,
	}

	[MapComponent]
	public struct AudioSource
	{
		public void PlaySound( string soundScript, AudioChannel channel = AudioChannel.Dynamic, bool fromStart = false )
		{

		}

		public void PauseSound( AudioChannel channel = AudioChannel.Dynamic )
		{

		}

		public void StopSound( AudioChannel channel = AudioChannel.Dynamic )
		{

		}
	}

	public enum DoorState
	{
		Closing,
		WasClosing,
		Closed,
		Opening,
		WasOpening,
		Open
	}

	[Requires<AudioSource>]
	[Requires<Transform>]
	[MapComponent]
	public struct Door
	{
		public Door() { }

		#region Properties
		public float OpenAngle { get; set; } = 90.0f;
		public float InitialAngle { get; set; } = 0.0f;
		public float Speed { get; set; } = 90.0f;
		public float TravelFraction { get; set; } = 0.0f;
		public DoorState State { get; set; } = DoorState.Closed;
		public bool IsOpen => State == DoorState.Open;
		public bool IsPartiallyOpen => State == DoorState.Open || State == DoorState.WasOpening || State == DoorState.WasClosing;
		public bool IsMoving => State == DoorState.Closing || State == DoorState.Opening;
		public bool NeedsUpdate => IsMoving;
		#endregion

		#region Utilities
		public void PlayDoorSound( GameEntity entity, bool open )
		{
			entity.AudioSource.PlaySound( "Door.Moving1", AudioChannel.Body1, true );
			entity.AudioSource.PlaySound( open ? "Door.Open1" : "Door.Close1", AudioChannel.Body2, true );
		}
		public void ContinueMovingSound( GameEntity entity )
		{
			entity.AudioSource.PlaySound( "Door.Moving1", AudioChannel.Body1 );
		}
		public void PauseMovingSound( GameEntity entity )
		{
			entity.AudioSource.PauseSound( AudioChannel.Body1 );
		}
		public void StopDoorSound( GameEntity entity, bool open )
		{
			PauseMovingSound( entity );
			entity.AudioSource.PlaySound( open ? "Door.OpenFinish1" : "Door.OpenFinish2", AudioChannel.Body2, true );
		}
		#endregion

		#region Events
		[Input]
		public void Open( GameEntity entity )
		{
			if ( State == DoorState.Open || State == DoorState.Opening )
			{
				return;
			}

			DoorState oldState = State;
			State = DoorState.Opening;

			HandleStateChange( oldState, entity );
		}

		[Input]
		public void Close( GameEntity entity )
		{
			if ( State == DoorState.Closed || State == DoorState.Closing )
			{
				return;
			}

			DoorState oldState = State;
			State = DoorState.Closing;

			HandleStateChange( oldState, entity );
		}

		[Input]
		public void Stop( GameEntity entity )
		{
			if ( !IsMoving )
			{
				return;
			}

			DoorState oldState = State;
			State = oldState == DoorState.Opening ? DoorState.WasOpening : DoorState.WasClosing;

			HandleStateChange( oldState, entity );
		}

		public void OnOpenBegin( GameEntity entity )
		{
			PlayDoorSound( entity, true );
			entity.FireOutputs( "OnOpenBegin" );
		}

		public void OnCloseBegin( GameEntity entity )
		{
			PlayDoorSound( entity, false );
			entity.FireOutputs( "OnCloseBegin" );
		}

		public void OnOpenPause( GameEntity entity ) => PauseMovingSound( entity );

		public void OnClosePause( GameEntity entity ) => PauseMovingSound( entity );

		public void OnOpenContinue( GameEntity entity ) => ContinueMovingSound( entity );

		public void OnCloseContinue( GameEntity entity ) => ContinueMovingSound( entity );

		public void OnOpenFinish( GameEntity entity )
		{
			StopDoorSound( entity, true );
			entity.FireOutputs( "OnOpenFinish" );
		}

		public void OnCloseFinish( GameEntity entity )
		{
			StopDoorSound( entity, false );
			entity.FireOutputs( "OnCloseFinish" );
		}
		#endregion

		public void HandleStateChange( DoorState oldState, GameEntity entity )
		{
			switch ( (oldState, State) )
			{
				// Was closed, now it's opening
				case (DoorState.Closed, DoorState.Opening): OnOpenBegin( entity ); break;
				// Was open, now it's closing
				case (DoorState.Open, DoorState.Closing): OnCloseBegin( entity ); break;
				// Was opening, now it's stopped
				case (DoorState.Opening, DoorState.WasOpening): OnOpenPause( entity ); break;
				// Was Closing, now it's stopped
				case (DoorState.Closing, DoorState.WasClosing): OnClosePause( entity ); break;

				// When you open/close the door midway
				case (DoorState.WasOpening, DoorState.Opening): OnOpenContinue( entity ); break;
				case (DoorState.WasOpening, DoorState.Closing): OnOpenContinue( entity ); break;
				case (DoorState.WasClosing, DoorState.Opening): OnCloseContinue( entity ); break;
				case (DoorState.WasClosing, DoorState.Closing): OnCloseContinue( entity ); break;

				// Door fully opened/closed normally
				case (DoorState.Open, DoorState.Opening): OnOpenFinish( entity ); break;
				case (DoorState.Open, DoorState.WasOpening): OnOpenFinish( entity ); break;
				case (DoorState.Closed, DoorState.Closing): OnCloseFinish( entity ); break;
				case (DoorState.Closed, DoorState.WasClosing): OnCloseFinish( entity ); break;
			}

			if ( oldState != State )
			{
				Console.WriteLine( $"Old state: {oldState}, new state: {State}" );
			}
		}

		private static Stream<GameEntity, Transform, Door>? mProcessStream = null;
		public static void Process( World world, float deltaTime )
		{
			if ( mProcessStream is null )
			{
				mProcessStream = world.Query<GameEntity, Transform, Door>().Stream();
			}

			mProcessStream.For( ( ref GameEntity entity, ref Transform transform, ref Door door ) =>
			{
				if ( !door.NeedsUpdate )
				{
					return;
				}

				DoorState oldState = door.State;

				float fractionTraveled = deltaTime * (door.Speed / door.OpenAngle);

				door.TravelFraction += door.State switch
				{
					DoorState.Closing => -fractionTraveled,
					DoorState.Opening => fractionTraveled,
					_ => 0.0f
				};

				(door.State, door.TravelFraction) = door.TravelFraction switch
				{
					>= 1.0f => (DoorState.Open, 1.0f),
					<= 0.0f => (DoorState.Closed, 0.0f),
					_ => (door.State, door.TravelFraction)
				};

				door.HandleStateChange( oldState, entity );

				// Update entity transform with this
				transform.SetYaw( door.InitialAngle + door.OpenAngle * door.TravelFraction );
				Console.WriteLine( $"Angle: {door.InitialAngle + door.OpenAngle * door.TravelFraction}" );
			} );
		}
	}

	public struct Transform
	{
		public Transform() { }

		public Vector3 Position { get; set; } = Vector3.Zero;
		public Quaternion Orientation { get; set; } = Quaternion.Identity;

		public void SetYaw( float degrees )
		{
			Orientation = Quaternion.CreateFromYawPitchRoll( degrees, 0.0f, 0.0f );
		}
	}

	internal class Program
	{
		static void Main( string[] args )
		{
			World world = new();
			GameEntity ge = new( world, new()
			{
				{ "Door.OpenAngle", "120" },
				{ "Door.Speed", "180" }
			} );

			ge.EcsEntity.Ref<Door>().Open( ge );
			for ( int i = 0; i < 100; i++ )
			{
				Door.Process( world, 0.016f );
				Console.WriteLine( $"TravelFraction: {ge.EcsEntity.Ref<Door>().TravelFraction}" );
			}
		}
	}
}
