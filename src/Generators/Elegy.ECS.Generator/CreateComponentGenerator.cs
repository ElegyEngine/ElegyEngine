// SPDX-FileCopyrightText: 2022-present Elegy Engine contributors
// SPDX-License-Identifier: MIT

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Elegy.ECS.Generator
{
	public class ComponentDependencyEntry
	{
		public string ComponentName { get; set; } = string.Empty;
		public string ComponentFullName { get; set; } = string.Empty;

		public List<string> DependencyNames { get; set; } = [];
		public List<string> DependencyFullNames { get; set; } = [];
	}

	[Generator]
	public class CreateComponentGenerator : IIncrementalGenerator
	{
		private static ComponentDependencyEntry ExtractComponentDependencyEntry( ITypeSymbol symbol, IEnumerable<string> fullNames )
		{
			string FindComponentFullName( string name )
			{
				foreach ( var fullName in fullNames )
				{
					if ( fullName.EndsWith( $".{name}" ) )
					{
						return fullName;
					}
				}

				return name;
			}

			ComponentDependencyEntry result = new()
			{
				ComponentName = symbol.Name,
				ComponentFullName = Utilities.GetFullName( symbol )
			};

			Console.WriteLine( $"Component: '{result.ComponentFullName}'" );
			Console.WriteLine( $"     a.k.a '{result.ComponentName}'" );

			foreach ( var attributeData in symbol.GetAttributes() )
			{
				if ( attributeData.AttributeClass is null )
				{
					continue;
				}

				string attributeName = attributeData.AttributeClass.Name;

				Console.WriteLine( $"  * Attrib: {attributeName}" );

				if ( attributeName.Contains( "Requires<" ) )
				{
					int leftArrow = attributeName.IndexOf( '<' ) + 1;
					int rightArrow = attributeName.LastIndexOf( '>' );

					string componentName = attributeName.Substring( leftArrow, rightArrow - leftArrow );
					Console.WriteLine( $"    * This one requires a '{componentName}' component!" );

					result.DependencyNames.Add( componentName );
					result.DependencyFullNames.Add( FindComponentFullName( componentName ) );
				}
			}

			return result;
		}

		public void Initialize( IncrementalGeneratorInitializationContext context )
		{
			Utilities.SetupSymbolBasedGenerator( context,
				implementationOutput: false,
				action: ( production, symbols ) =>
				{
					// Step 1: obtain full names of all component types
					var components = symbols
						.Where( s => Utilities.HasAttribute( s, "Elegy.ECS.GameComponentAttribute" ) );

					var componentFullNames = components
						.Select( s => Utilities.GetFullName( (ITypeSymbol)s ) );

					// Step 2: get a list of dependencies for each component
					var componentsWithRequires = components
						.Where( s => Utilities.HasAttribute( s, "Elegy.ECS.Requires", partial: true ) );

					// Step 3: generate component dependency data
					var componentDependencies = componentsWithRequires
						.Select( s => ExtractComponentDependencyEntry( (ITypeSymbol)s, componentFullNames ) );

					// Step 4: obtain the component registry name
					string? fullRegistryName = Utilities.GetComponentRegistryFullName( symbols );
					if ( fullRegistryName is null )
					{
						throw new EntryPointNotFoundException( "There's no type that is marked with 'GenerateComponentRegistry'" );
					}

					(string registryNamespaces, string registryName) = Utilities.SeparateNamespaceAndTypename( fullRegistryName );

					// Step 5: generate!

					StringBuilder sb = new();
					sb.AppendLine(
					$$"""
					// This madness was auto-generated by Elegy.ECS.Generator
					
					using System;
					using fennecs;
					using Elegy.ECS;
					
					namespace {{registryNamespaces}};

					public static partial class {{registryName}}
					{
						public static partial ref T Create<T>( Entity entity )
							where T: notnull, new()
						{
							var typeOfT = typeof( T );
							// We create the component first, so that further Has<T>
							// checks will return true
							ref T result = ref GetComp<T>( entity );
					""" );

					foreach ( var item in componentDependencies )
					{
						sb.AppendLine(
					$$"""
							if ( typeOfT == typeof( {{item.ComponentFullName}} ) )
							{
					""" );

						foreach ( var dependency in item.DependencyFullNames )
						{
							sb.AppendLine(
					$$"""
								if ( !entity.Has<{{dependency}}>() )
								{
									Create<{{dependency}}>( entity );
								}
					""" );
						}

						sb.AppendLine(
					"""
							}
					""" );

					}

					sb.AppendLine(
					"""
							return ref result;
						}
					}
					""" );

					production.AddSource( "ComponentRegistry.Create.generated.cs",
						SourceText.From( sb.ToString(), Encoding.UTF8 ) );
				} );
		}
	}
}
