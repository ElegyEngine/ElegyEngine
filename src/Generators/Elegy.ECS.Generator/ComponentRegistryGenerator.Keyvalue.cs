// SPDX-FileCopyrightText: 2022-present Elegy Engine contributors
// SPDX-License-Identifier: MIT

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Elegy.ECS.Generator
{
	public partial class ComponentRegistryGenerator
	{
		private bool NeedsCustomParser( in string datatype )
			=> datatype switch
			{
				"string" or
				"bool" or
				"int" or
				"byte" or
				"short" or
				"float" or
				"double" or
				"Vector2" or
				"Vector2D" or
				"Vector2I" or
				"Vector3" or
				"Vector3D" or
				"Vector3I" or
				"Vector4" or
				"Vector4B" or
				"Vector4D" or
				"Vector4I" => false,

				_ => true
			};

		private string GetParser( in string datatype, List<SimpleTypeInfo> customProperties )
			=> datatype switch
			{
				"string" => "value",
				"bool" => "Parse.Int( value ) != 0",
				"int" => "Parse.Int( value )",
				"byte" => "(byte)Parse.Int( value )",
				"short" => "(short)Parse.Int( value )",
				"float" => "Parse.Float( value )",
				"double" => "(double)Parse.Float( value )",

				"Vector2" => "Parse.Vector2( value )",
				"Vector2D" => "Parse.Vector2D( value )",
				"Vector2I" => "Parse.Vector2I( value )",
				"Vector3" => "Parse.Vector3( value )",
				"Vector3D" => "Parse.Vector3D( value )",
				"Vector3I" => "Parse.Vector3I( value )",
				"Vector4" => "Parse.Vector4( value )",
				"Vector4B" => "Parse.Vector4B( value )",
				"Vector4D" => "Parse.Vector4D( value )",
				"Vector4I" => "Parse.Vector4I( value )",

				_ => "default"
			};

		private string GenerateParser( SimpleTypeInfo component, SimplePropertyInfo property, List<SimpleTypeInfo> entityProperties )
		{
			StringBuilder sb = new();

			// We'll still allow unknown property types to compile
			// Just make sure to warn the user
			bool unknownPropertyType = !entityProperties.Any( p => property.Datatype.EndsWith( p.Name ) );

			if ( NeedsCustomParser( property.Datatype ) && !unknownPropertyType )
			{
				sb.AppendLine(
			$$"""
						entity.Ref<global::{{component.FullName}}>()
							.{{property.Name}} = {{property.Datatype}}.ParseEntityProperty( ref entity, key, value );
			"""	
				);
			}
			else
			{
				if ( unknownPropertyType )
				{
					// Log diagnostic error
					// I forgot how to do that
				}

				sb.AppendLine(
			$$"""
						entity.Ref<global::{{component.FullName}}>()
							.{{property.Name}} = {{GetParser( property.Datatype, entityProperties )}};
			"""
				);

			}

			return sb.ToString();
		}

		private void GeneratePreKeyvalue(
			SourceProductionContext production, SimpleTypeInfo registry,
			List<SimpleTypeInfo> components, List<SimpleTypeInfo> customEntityProperties )
		{
			StringBuilder sb = new();
			sb.AppendLine(
				$$"""
				  // This madness was auto-generated by Elegy.ECS.Generator

				  using System;
				  using Elegy.Common.Utilities;

				  namespace {{registry.Namespace}};

				  public partial {{registry.Kind.ToString().ToLower()}} {{registry.Name}}
				  {
				  	/// <summary>
				  	/// Creates components from keyvalues.
				  	/// </summary>
				  	public static bool PrepareComponentForKeyvalue( ref fennecs.Entity entity, ReadOnlySpan<char> key )
				  	{
				  		switch ( key )
				  		{
				  """ );

			foreach ( var component in components )
			{
				foreach ( var property in component.Properties.Where( p => p.HasAttribute( "Property" ) ) )
				{
					sb.AppendLine(
						$"""
						 		case "{component.Name}.{property.Name}":
						 			CreateOrRef<global::{component.FullName}>( ref entity );
						 			break;
						 """
					);
				}
			}

			sb.AppendLine(
				"""
						default: return false;
						}
				
						return true;
					}
				}
				""" );

			production.AddSource( $"{registry.Name}.PreKeyvalues.generated.cs",
				SourceText.From( sb.ToString(), Encoding.UTF8 ) );
		}
		
		private void GenerateKeyvalue( SourceProductionContext production, SimpleTypeInfo registry,
			List<SimpleTypeInfo> components, List<SimpleTypeInfo> customEntityProperties )
		{
			StringBuilder sb = new();
			sb.AppendLine(
			$$"""
			// This madness was auto-generated by Elegy.ECS.Generator
			
			using System;
			using Elegy.Common.Utilities;
			
			namespace {{registry.Namespace}};

			public partial {{registry.Kind.ToString().ToLower()}} {{registry.Name}}
			{
				/// <summary>
				/// Deserialises an entity from text data embedded in the level.
				/// Also creates components ad-hoc.
				/// </summary>
				public static bool ParseComponentKeyvalue( ref fennecs.Entity entity, ReadOnlySpan<char> key, string value )
				{
					switch ( key )
					{
			""" );

			foreach ( var component in components )
			{
				foreach ( var property in component.Properties.Where( p => p.HasAttribute( "Property" ) ) )
				{
					sb.AppendLine(
			$"""
					case "{component.Name}.{property.Name}":
			{GenerateParser( component, property, customEntityProperties )}
						break;
			"""
					);
				}
			}

			sb.AppendLine(
			"""
					default: return false;
					}

					return true;
				}
			}
			""" );

			production.AddSource( $"{registry.Name}.Keyvalues.generated.cs",
				SourceText.From( sb.ToString(), Encoding.UTF8 ) );
		}
	}
}
