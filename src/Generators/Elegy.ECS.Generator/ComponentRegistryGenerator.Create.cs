// SPDX-FileCopyrightText: 2022-present Elegy Engine contributors
// SPDX-License-Identifier: MIT

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Elegy.ECS.Generator
{
	public partial class ComponentRegistryGenerator
	{
		private ComponentDependencyEntry ExtractComponentDependencyEntry(
			List<SimpleTypeInfo> allComponents,
			SimpleTypeInfo component )
		{
			SimpleTypeInfo? findDependency( string name )
			{
				foreach ( var component in allComponents )
				{
					if ( component.FullName.EndsWith( name ) )
					{
						return component;
					}
				}

				return null;
			}

			ComponentDependencyEntry result = new( component );

			foreach ( var attribute in component.Attributes )
			{
				if ( attribute.Contains( "Requires<" ) )
				{
					string dependencyShortName = Utilities.GetGenericArgument( attribute );

					var dependency = findDependency( dependencyShortName );
					if ( dependency is null )
					{
						continue;
					}

					result.Dependencies.Add( dependency );
				}
			}

			return result;
		}

		private void GenerateCreate( SourceProductionContext production, SimpleTypeInfo registry,
			List<SimpleTypeInfo> components )
		{
			// Step 1: get a list of dependencies for each component
			var componentsWithRequires = components
				.Where( c => c.HasAttribute( "Requires<", partial: true ) );

			// Step 2: generate component dependency data
			var dependencyData = componentsWithRequires
				.Select( c => ExtractComponentDependencyEntry( components, c ) );

			// Step 3: generate!
			StringBuilder sb = new();
			sb.AppendLine(
			$$"""
			// This madness was auto-generated by Elegy.ECS.Generator
			
			using System;
			using fennecs;
			using Elegy.ECS;
			
			namespace {{registry.Namespace}};

			public partial {{registry.Kind.ToString().ToLower()}} {{registry.Name}}
			{
				/// <summary>
				/// Creates a component, keeping in mind <see cref="RequiresAttribute{T}"/> i.e. component dependencies.
				/// </summary>
				public static ref T CreateOrRef<T>( fennecs.Entity entity )
					where T: new()
				{
					var typeOfT = typeof( T );
					// We create the component first, so that further Has<T>
					// checks will return true
					ref T result = ref GetComp<T>( entity );
			""" );

			foreach ( var item in dependencyData )
			{
				sb.AppendLine(
			$$"""
					if ( typeOfT == typeof( global::{{item.Component.FullName}} ) )
					{
			""" );

				foreach ( var dependency in item.Dependencies )
				{
					sb.AppendLine(
			$$"""
						if ( !entity.Has<global::{{dependency.FullName}}>() )
						{
							CreateOrRef<global::{{dependency.FullName}}>( entity );
						}
			""" );
				}

				sb.AppendLine(
			"""
					}
			""" );

			}

			sb.AppendLine(
			"""
					return ref result;
				}
			}
			""" );

			production.AddSource( $"{registry.Name}.Create.generated.cs",
				SourceText.From( sb.ToString(), Encoding.UTF8 ) );
		}
	}
}
