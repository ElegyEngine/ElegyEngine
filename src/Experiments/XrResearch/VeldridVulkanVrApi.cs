using Silk.NET.OpenXR;
using TerraFX.Interop.Vulkan;
using Veldrid;
using Veldrid.Vulkan;
using Swapchain = Silk.NET.OpenXR.Swapchain;

namespace XrResearch;

public unsafe class VeldridVulkanVrApi : IVrGraphicsApi
{
	private GraphicsDevice mDevice;
	private BackendInfoVulkan mVulkan;
	private Dictionary<Swapchain, (bool, SwapchainImageVulkanKHR[])> mSwapchainImages = new();
	private Dictionary<Swapchain, List<Framebuffer>> mSwapchainFramebuffers = new();

	#region Formats

	private readonly PixelFormat[] mSupportedFormats =
	[
		PixelFormat.B8_G8_R8_A8_UNorm_SRgb,
		PixelFormat.R8_G8_B8_A8_UNorm_SRgb,
		PixelFormat.B8_G8_R8_A8_UNorm,
		PixelFormat.R8_G8_B8_A8_UNorm
	];

	private readonly VkFormat[] mSupportedVkFormats =
	[
		VkFormat.VK_FORMAT_B8G8R8A8_SRGB,
		VkFormat.VK_FORMAT_R8G8B8A8_SRGB,
		VkFormat.VK_FORMAT_B8G8R8A8_UNORM,
		VkFormat.VK_FORMAT_R8G8B8A8_UNORM
	];

	private readonly PixelFormat[] mSupportedDepthFormats =
	[
		PixelFormat.D32_Float
	];

	private readonly VkFormat[] mSupportedVkDepthFormats =
	[
		VkFormat.VK_FORMAT_D32_SFLOAT
	];

	#endregion

	public VeldridVulkanVrApi( GraphicsDevice device )
	{
		mDevice = device;
		mVulkan = device.GetVulkanInfo();
	}

	public long SelectColorSwapchainFormat( ReadOnlySpan<long> formats )
	{
		for ( int i = 0; i < mSupportedFormats.Length; i++ )
		{
			for ( int j = 0; j < formats.Length; j++ )
			{
				if ( (long)mSupportedVkFormats[i] == formats[j] )
				{
					return (long)mSupportedVkFormats[i];
				}
			}
		}

		return 0;
	}

	public long SelectDepthSwapchainFormat( ReadOnlySpan<long> formats )
	{
		for ( int i = 0; i < mSupportedDepthFormats.Length; i++ )
		{
			for ( int j = 0; j < formats.Length; j++ )
			{
				if ( (long)mSupportedVkDepthFormats[i] == formats[j] )
				{
					return (long)mSupportedVkDepthFormats[i];
				}
			}
		}

		return 0;
	}

	public void CreateFramebuffers( in SwapchainInfo colorInfo, in SwapchainInfo depthInfo )
	{
		for ( int i = 0; i < colorInfo.ImageViews.Count; i++ )
		{
			FramebufferAttachmentDescription colorAttachment = new()
			{
				ArrayLayer = 0U,
				Target = ((TextureView)colorInfo.ImageViews[i]).Target
			};

			FramebufferAttachmentDescription depthAttachment = new()
			{
				ArrayLayer = 0U,
				Target = ((TextureView)depthInfo.ImageViews[i]).Target
			};

			FramebufferDescription fbDesc = new()
			{
				ColorTargets = [colorAttachment],
				DepthTarget = depthAttachment,

				// For now let's just do 2 eyes until I get a quad headset
				MultiviewMasks = [0b11]
			};

			var framebuffer = mDevice.ResourceFactory.CreateFramebuffer( fbDesc );

			if ( !mSwapchainFramebuffers.ContainsKey( colorInfo.Swapchain ) )
			{
				mSwapchainFramebuffers[colorInfo.Swapchain] = new( colorInfo.ImageViews.Count );
			}

			mSwapchainFramebuffers[colorInfo.Swapchain].Add( framebuffer );
		}
	}

	public object GetFramebuffer( Swapchain swapchain, uint arrayLayer )
	{
		return mSwapchainFramebuffers[swapchain][(int)arrayLayer];
	}

	public GraphicsBinding GetGraphicsBinding()
		=> new()
		{
			Type = StructureType.GraphicsBindingVulkanKhr,
			VulkanKhr = new()
			{
				Type = StructureType.GraphicsBindingVulkanKhr,
				Device = new( mVulkan.Device ),
				PhysicalDevice = new( mVulkan.PhysicalDevice ),
				Instance = new( mVulkan.Instance ),
				QueueIndex = 0,
				QueueFamilyIndex = mVulkan.GraphicsQueueFamilyIndex
			}
		};

	public object CreateSwapchainImage( Swapchain swapchain, uint index, bool depth )
	{
		// This is a native Vulkan image handle, generated by the VR runtime,
		// we need to convert it into the RHI's representation of textures
		ulong vkImageHandle = mSwapchainImages[swapchain].Item2[index].Image;

		// Veldrid has an API to create textures from native image handles,
		// BUT, it sets isSwapchainTexture to false, so screw you
		return new VkTexture(
			// TODO: get below from OpenXR-provided metadata
			width: Program.GetVrSwapchainWidth(),
			height: Program.GetVrSwapchainHeight(),
			mipLevels: 1U,
			arrayLayers: (uint)Program.GetVrArrayLayerCount(),

			// TODO: verify stuff below
			vkFormat: depth
				? VkFormat.VK_FORMAT_D32_SFLOAT
				: VkFormat.VK_FORMAT_B8G8R8A8_SRGB,
			usage: depth
				? TextureUsage.DepthStencil | TextureUsage.Sampled
				: TextureUsage.RenderTarget | TextureUsage.Sampled,
			sampleCount: TextureSampleCount.Count1,

			// The rest is fine
			gd: (VkGraphicsDevice)mDevice,
			existingImage: new VkImage( vkImageHandle ),
			// this parametre here is why I made all the internals public
			isSwapchainTexture: true,
			// true because this is created by OpenXR, mustn't dispose this ourselves
			leaveOpen: true,
			// true because OpenXR won't let us clear this stuff until we acquire the swapchain
			skipClear: true
		);
	}

	public object CreateImageView( ImageViewCreateInfo info )
	{
		TextureViewDescription viewDesc = new()
		{
			Target = (Texture)info.Image,
			ArrayLayers = (uint)info.LayerCount,
			Format = info.IsDepth ? PixelFormat.R32_Float : PixelFormat.B8_G8_R8_A8_UNorm_SRgb,
			MipLevels = 1,
			BaseMipLevel = 0,
			BaseArrayLayer = 0
		};

		return mDevice.ResourceFactory.CreateTextureView( viewDesc );
	}

	public void DestroyFramebuffers()
	{
		foreach ( var item in mSwapchainFramebuffers )
		{
			foreach ( var framebuffer in item.Value )
			{
				framebuffer.Dispose();
			}
		}
	}

	public void DestroyImageView( object imageView )
	{
		((TextureView)imageView).Dispose();
	}

	public Span<SwapchainImageBaseHeader> AllocateSwapchainImageData( Swapchain swapchain, uint count, bool depth )
	{
		mSwapchainImages[swapchain] = new()
		{
			Item1 = depth,
			Item2 = new SwapchainImageVulkanKHR[count]
		};

		return new Span<SwapchainImageBaseHeader>( mSwapchainImages[swapchain].Item2.AsSpan().AsIntPtr().Deref<SwapchainImageBaseHeader>(),
			(int)count );
	}

	public void FreeSwapchainImageData( Swapchain swapchain )
	{
		Array.Clear( mSwapchainImages[swapchain].Item2 );
		mSwapchainImages.Remove( swapchain );
	}
}
