<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Elegy.Common</name>
    </assembly>
    <members>
        <member name="T:Elegy.Assets.ElegyMapData.CollisionMeshlet">
            <summary>
            A collision submesh.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.CollisionMeshlet.Positions">
            <summary>
            Triplets of vector positions, forming collision triangles.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.CollisionMeshlet.MaterialName">
            <summary>
            Material that this mesh is associated with.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ElegyMapData.CollisionMesh">
            <summary>
            A collision mesh.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.CollisionMesh.Meshlets">
            <summary>
            Collision submeshes.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.Entity.OccluderMeshId">
            <summary>
            Brush entities can have occluder meshes associated
            with them. E.g. doors may block visibility.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ElegyMapData.OccluderMesh">
            <summary>
            Mesh used for occlusion culling.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.OccluderMesh.Positions">
            <summary>
            Vertex buffer.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.OccluderMesh.Indices">
            <summary>
            Index buffer.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ElegyMapData.RenderMesh">
            <summary>
            A render mesh is a collection of renderable surfaces.
            Definitely read more about <seealso cref="T:Elegy.Assets.ElegyMapData.RenderSurface"/>.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderMesh.Surfaces">
            <summary>
            The render surfaces of this mesh.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ElegyMapData.RenderSurface">
            <summary>
            An ELF render surface is concrete render data that describes
            a little part of world geometry. It is not necessarily a
            single face or a few coplanar faces, but rather a mesh consisting
            of all faces belonging to one octree leaf, where the faces share the same material.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.BoundingBox">
            <summary>
            AABB of this render surface.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Positions">
            <summary>
            Position buffer.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Normals">
            <summary>
            Normal buffer. Tangents and bitangents
            are built from normals and UVs.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Uvs">
            <summary>
            UV buffer.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.LightmapUvs">
            <summary>
            Secondary UV buffer for lightmaps.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Colours">
            <summary>
            Colour buffer.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Indices">
            <summary>
            Index buffer.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.VertexCount">
            <summary>
            Actual number of vertices.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.Material">
            <summary>
            The name of the material associated with this surface.
            Multimaterials could perhaps be autogenerated from a collection
            of surfaces with fundamentally similar materials.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapData.RenderSurface.LightmapTexture">
            <summary>
            Lightmap texture name. It's up to the engine to autogenerate
            materials for these lightmaps.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ElegyMapDocument">
            <summary>
            Standard Elegy level format.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapDocument.WorldMeshIds">
            <summary>
            IDs of world meshes.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapDocument.Entities">
            <summary>
            Map entities.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapDocument.CollisionMeshes">
            <summary>
            Collision meshes for collision detection.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapDocument.OccluderMeshes">
            <summary>
            Occluder meshes for real-time dynamic occlusion culling.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ElegyMapDocument.RenderMeshes">
            <summary>
            Visual renderable meshes.
            </summary>
        </member>
        <member name="M:Elegy.Assets.ElegyMapDocument.WriteToFile(System.String)">
            <summary>
            Writes the contents of this <see cref="T:Elegy.Assets.ElegyMapDocument"/> to a file.
            </summary>
        </member>
        <member name="M:Elegy.Assets.ElegyMapDocument.LoadFromFile(System.String)">
            <summary>
            Loads an <see cref="T:Elegy.Assets.ElegyMapDocument"/> from a file.
            </summary>
            <exception cref="T:System.Exception">File isn't an ELF</exception>
        </member>
        <member name="T:Elegy.Assets.MaterialDefinition">
            <summary>
            A material defined inside a material document.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.Name">
            <summary>
            Material name.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.TemplateName">
            <summary>
            Name of the material template.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.Parameters">
            <summary>
            Shader parameters.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.ToolParameters">
            <summary>
            Map compiler parameters.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.ToolFlags">
            <summary>
            Map compiler flags.
            </summary>
        </member>
        <member name="M:Elegy.Assets.MaterialDefinition.GetParameterString(System.String)">
            <summary>
            Safely obtain a parameter string.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDefinition.DiffuseMap">
            <summary>
            Diffuse map.
            </summary>
        </member>
        <member name="T:Elegy.Assets.MaterialDocument">
            <summary>
            Elegy material document.
            </summary>
        </member>
        <member name="M:Elegy.Assets.MaterialDocument.#ctor(System.String)">
            <summary>
            Parses a material document from given text,
            loaded from a file or generated elsewhere.
            </summary>
        </member>
        <member name="P:Elegy.Assets.MaterialDocument.Materials">
            <summary>
            The materials defined in this document.
            </summary>
        </member>
        <member name="T:Elegy.Assets.Model">
            <summary>
            Raw data for Elegy models. Models can represent NPCs, weapons,
            terrain, 3D UIs, props and other things. Elegy's model format is
            generally concerned with monolithic models for individual entities,
            as opposed to models that host entire scenes and submodels.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ModelData.Vertex">
            <summary>
            All possible vertex data that can be stored in EMFs.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ModelData.Mesh">
            <summary>
            Represents a particular part of a model with a material assigned to it.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ModelData.Mesh.Name">
            <summary>
            Name of the model, usually the file name.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ModelData.Mesh.MaterialName">
            <summary>
            Material name, is used by the renderer system to look for materials.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ModelData.Mesh.Vertices">
            <summary>
            Vertex data.
            </summary>
        </member>
        <member name="P:Elegy.Assets.ModelData.Mesh.Indices">
            <summary>
            Vertex indices.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ModelData.BoneJoint">
            <summary>
            Represents a joint between 2 bones.
            It is basically a transformation matrix with a name.
            </summary>
        </member>
        <member name="T:Elegy.Assets.ToolMaterialFlag">
            <summary>
            Compiling flags that can be had by materials.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.NoDraw">
            <summary>
            This surface isn't drawn.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.Origin">
            <summary>
            This is used to determine centres of brush entities.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.Occluder">
            <summary>
            This surface acts as a runtime occluder.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.NoShadowCast">
            <summary>
            Do not cast shadows e.g. when baking lightmaps.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.NoLightmapReceived">
            <summary>
            Lightmap UV space won't be allocated for this material.
            </summary>
        </member>
        <member name="F:Elegy.Assets.ToolMaterialFlag.NoCollision">
            <summary>
            This surface has no collision.
            </summary>
        </member>
        <member name="T:Elegy.Collections.Octree`1">
            <summary>
            An octree container.
            Elegy.MapCompiler uses them to quickly and roughly subdivide a level.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Elegy.Collections.Octree`1.#ctor(Godot.Aabb,System.Collections.Generic.IReadOnlyList{`0},Elegy.Collections.STree{Godot.Aabb,`0}.IsInBoundFn,Elegy.Collections.STree{Godot.Aabb,`0}.ShouldSubdivideFn,System.Boolean)">
            <summary>
            Constructs an octree.
            </summary>
            <param name="rootBound">
            The bounding box of the tree's root.
            </param>
            <param name="items">
            A list of items of the tree. Can be empty for a start, as the tree is only constructed later.
            </param>
            <param name="isInBoundMethod">
            A method that checks whether or not an AABB of an octree node intersects with an item. Look at <see cref="M:Elegy.Collections.STreeUtilities.IsInBoundVector3"/>.
            </param>
            <param name="shouldSubdivideMethod">
            A method that says whether or not a given node should subdivide. Look at <see cref="M:Elegy.Collections.STreeUtilities.ShouldSubdivideThreshold``2(System.Int32)"/>.
            </param>
            <param name="onlyFirstIntersection">
            When collecting intersections, one (<c>true</c>) or multiple (<c>false</c>) children will receive a reference to a given item.
            If you have geometric objects that happen to be inside multiple nodes, this is pretty relevant.
            </param>
        </member>
        <member name="T:Elegy.Collections.Quadtree`1">
            <summary>
            A quadtree. Dunno what you'd use it for, vegetation maybe.
            </summary>
        </member>
        <member name="M:Elegy.Collections.Quadtree`1.#ctor(Godot.Rect2,System.Collections.Generic.IReadOnlyList{`0})">
            <summary>
            
            </summary>
            <param name="rootBound"></param>
            <param name="items"></param>
        </member>
        <member name="T:Elegy.Collections.STree`2">
            <summary>
            N-dimensional spatial tree (s-tree) that stores <typeparamref name="TItem"/>s inside a <typeparamref name="TBound"/>.
            </summary>
            <typeparam name="TBound">
            For example: <seealso cref="T:Godot.Aabb"/> or <seealso cref="T:Godot.Rect2"/>.
            </typeparam>
            <typeparam name="TItem">
            For example: <seealso cref="T:Godot.Vector3"/> or anything, really!
            </typeparam>
        </member>
        <member name="T:Elegy.Collections.STree`2.IsInBoundFn">
            <summary>
            Does the item intersect the bound?
            </summary>
        </member>
        <member name="T:Elegy.Collections.STree`2.ShouldSubdivideFn">
            <summary>
            With these elements loaded, should this node subdivide any further?
            </summary>
        </member>
        <member name="T:Elegy.Collections.STree`2.GetChildVolumeFn">
            <summary>
            Get a subdivided bounding volume for the Nth child node
            </summary>
        </member>
        <member name="T:Elegy.Collections.STree`2.CollectIntersectionsFn">
            <summary>
            If two or more intersections occur within the node's children, resolve them.
            </summary>
            <returns>True on successful resolution, false if there were no usable intersections at all.</returns>
        </member>
        <member name="P:Elegy.Collections.STree`2.Combinations">
            <summary>
            Usually **the** number of children that must be had.
            Technically the max number of children that this node may have.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.Dimensions">
            <summary>
            Dimensionality of this tree (2 or 3 usually).
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.Bound">
            <summary>
            Bounding volume of this tree.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.Items">
            <summary>
            This tree's items.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.Nodes">
            <summary>
            All of the nodes belonging to this tree.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.Leaves">
            <summary>
            A subset of <c>Nodes</c> which are leaf nodes.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.IsInBound">
            <summary>
            See <see cref="T:Elegy.Collections.STree`2.IsInBoundFn"/>.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.ShouldSubdivide">
            <summary>
            See <see cref="T:Elegy.Collections.STree`2.ShouldSubdivideFn"/>.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.GetChildVolume">
            <summary>
            See <see cref="T:Elegy.Collections.STree`2.GetChildVolumeFn"/>.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STree`2.CollectIntersections">
            <summary>
            See <see cref="T:Elegy.Collections.STree`2.CollectIntersectionsFn"/>.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STree`2.#ctor(`0,System.Collections.Generic.IReadOnlyList{`1},System.Int32)">
            <summary>
            The constructor for this thing.
            </summary>
            <param name="rootBound">The bounding volume of the root node.</param>
            <param name="items"></param>
            <param name="dimensions"></param>
        </member>
        <member name="M:Elegy.Collections.STree`2.Clear">
            <summary>
            Clears the tree.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STree`2.Add(`1)">
            <summary>
            Adds an item into the octree, without linking.
            If you'd like to rebuild the octree, call Build
            </summary>
        </member>
        <member name="M:Elegy.Collections.STree`2.Build">
            <summary>
            Builds the tree.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STree`2.BuildNode(Elegy.Collections.STreeNode{`0,`1})">
            <summary>
            Builds nodes recursively.
            </summary>
        </member>
        <member name="T:Elegy.Collections.STreeNode`2">
            <summary>
            N-dimensional tree node, stores a list of <typeparamref name="TItem"/>s
            from its parent tree that intersect with its <typeparamref name="TBound"/>.
            </summary>
            <typeparam name="TBound">
            For example: <seealso cref="T:Godot.Aabb"/> or <seealso cref="T:Godot.Rect2"/>.
            </typeparam>
            <typeparam name="TItem">
            For example: <seealso cref="T:Godot.Vector3"/> or anything, really!
            </typeparam>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.Combinations">
            <summary>
             How many child nodes there can be.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.Dimensions">
            <summary>
            The dimensionality of this node.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.NumItems">
            <summary>
            Number of items currently linked to this node.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.Bound">
            <summary>
            The bounding volume of this node.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.ItemIndices">
            <summary>
            The items of this node.
            </summary>
        </member>
        <member name="P:Elegy.Collections.STreeNode`2.Children">
            <summary>
            This node's children.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.#ctor(`0,System.Int32)">
            <summary>
            The constructor of this tree node.
            </summary>
            <param name="bound">
            The bounding volume to bind a subset of items to.
            </param>
            <param name="dimensions">
            Dimensionality of the tree. (2 or 3 usually)
            </param>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.Add(System.Int32,System.Boolean)">
            <summary>
            Adds an item to the node. The <paramref name="unique"/> parameter can 
            affect performance and is needless if your indices are guaranteed to be unique.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.CreateChildren(System.Collections.Generic.List{Elegy.Collections.STreeNode{`0,`1}},Elegy.Collections.STree{`0,`1}.GetChildVolumeFn)">
            <summary>
            Creates children for this node, not recursive though!
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.IsLeaf">
            <summary>
            Returns whether this node is a leaf or not.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.IsEmpty">
            <summary>
            Returns whether this node is empty.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.ForEachChildNode(System.Action{Elegy.Collections.STreeNode{`0,`1}})">
            <summary>
            Executes the <paramref name="method"/> for each child node.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeNode`2.ForEachItem(System.Collections.Generic.IReadOnlyList{`1},System.Action{`1})">
            <summary>
            Executes the <paramref name="method"/> for each item.
            </summary>
        </member>
        <member name="T:Elegy.Collections.STreeUtilities">
            <summary>
            Built-in helper methods for <seealso cref="T:Elegy.Collections.STree`2"/>.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.IsInBoundVector3">
            <summary>
            TBound: <see cref="T:Godot.Aabb"/>
            TItem: <see cref="T:Godot.Vector3"/>
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.IsInBoundVector4">
            <summary>
            TBound: <see cref="T:Godot.Aabb"/>
            TItem: <see cref="T:Godot.Vector4"/>
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.ShouldSubdivideThreshold``2(System.Int32)">
            <summary>
            Very simple threshold-based subdivision function.
            If a node has more than <paramref name="threshold"/> elements, it'll subdivide.
            If not, it'll become a leaf.
            </summary>
        </member>
        <member name="F:Elegy.Collections.STreeUtilities.OctreeMinMaxIndices">
            <summary>
            Look at <see cref="M:Elegy.Collections.STreeUtilities.GetChildVolumeOctree``1"/> to see the usage of this.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.GetChildVolumeOctree``1">
            <summary>
            Subdivides an AABB into 8 equal octants.
            Restriction: dimensionality must be 3.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.CollectIntersectionsOctreeAll``1(Elegy.Collections.STree{Godot.Aabb,``0}.IsInBoundFn)">
            <summary>
            Accumulates all intersections into a node's children. Meaning if your item intersects all children, all children get that item.
            </summary>
        </member>
        <member name="M:Elegy.Collections.STreeUtilities.CollectIntersectionsOctreeFirst``1(Elegy.Collections.STree{Godot.Aabb,``0}.IsInBoundFn)">
            <summary>
            Only takes in the first intersection.
            </summary>
        </member>
        <member name="T:Elegy.Reflection.MemberWrapper">
            <summary>
            Wrapper for reflected C# members.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.MemberWrapper.Attributes">
            <summary>
            Attributes of this property or method.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MemberWrapper.HasAttribute``1">
            <summary>
            Returns whether or not this property has an instace of <typeparamref name="TAttribute"/>.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MemberWrapper.GetAttribute``1">
            <summary>
            Gets an attribute if it's applied to this property.
            </summary>
        </member>
        <member name="T:Elegy.Reflection.MethodWrapper">
            <summary>
            Utility to easily interact with C# methods.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.MethodWrapper.Info">
            <summary>
            More detailed info about the method.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.MethodWrapper.ReturnType">
            <summary>
            The return type of this method.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MethodWrapper.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Constructs a <see cref="T:Elegy.Reflection.MethodWrapper"/> from the given <paramref name="info"/>,
            caching its metadata.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MethodWrapper.Invoke``1(System.Object)">
            <summary>
            Invokes this <paramref name="obj"/>'s method, with a return value but no arguments.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MethodWrapper.Invoke``1(System.Object,System.Object[])">
            <summary>
            Invokes this <paramref name="obj"/>'s method, with a return value and one or more arguments.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MethodWrapper.Invoke(System.Object)">
            <summary>
            Invokes this <paramref name="obj"/>'s method, with no return value and no arguments.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.MethodWrapper.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes this <paramref name="obj"/>'s method, with no return value.
            </summary>
        </member>
        <member name="T:Elegy.Reflection.PropertyWrapper">
            <summary>
            Utility to easily interact with C# properties.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.PropertyWrapper.Info">
            <summary>
            More detailed info about the property.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.PropertyWrapper.Type">
            <summary>
            The type of the value behind the property.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.PropertyWrapper.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Constructs a <see cref="T:Elegy.Reflection.PropertyWrapper"/> from the given <paramref name="info"/>,
            caching its metadata.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.PropertyWrapper.Set``1(System.Object,``0)">
            <summary>
            Sets the value of this property in the current object <paramref name="obj"/>.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.PropertyWrapper.Get``1(System.Object)">
            <summary>
            Gets the value of this property in the current object <paramref name="obj"/>.
            </summary>
        </member>
        <member name="T:Elegy.Reflection.TypeCache">
            <summary>
            The global type cache.
            It accelerates queries about datatypes.
            </summary>
        </member>
        <member name="T:Elegy.Reflection.TypeInfo">
            <summary>
            Caches a bunch of metadata about a given datatype.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.TypeInfo.Attributes">
            <summary>
            The attributes this type has.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.TypeInfo.Properties">
            <summary>
            This type's properties.
            </summary>
        </member>
        <member name="P:Elegy.Reflection.TypeInfo.Methods">
            <summary>
            This type's methods.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.TypeInfo.From``1">
            <summary>
            Gathers all type information from <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Elegy.Reflection.TypeInfo.#ctor(System.Type)">
            <summary>
            Gathers all type information from the given type.
            </summary>
        </member>
        <member name="T:Elegy.Text.JsonHelpers">
            <summary>
            JSON reading and writing utilities.
            </summary>
        </member>
        <member name="M:Elegy.Text.JsonHelpers.LoadFrom``1(``0@,System.String)">
            <summary>
            Reads JSON data from <paramref name="path"/> and stores it into
            <paramref name="outObject"/>.
            </summary>
            <returns><c>true</c> on success, <c>false</c> if the file cannot be found.</returns>
        </member>
        <member name="M:Elegy.Text.JsonHelpers.LoadFrom``1(System.String)">
            <summary>
            Reads JSON data from <paramref name="path"/> and returns it as a/an <typeparamref name="T"/>.
            </summary>
            <returns><c>true</c> on success, <c>false</c> if the file cannot be found.</returns>
        </member>
        <member name="M:Elegy.Text.JsonHelpers.Write``1(``0,System.String)">
            <summary>
            Writes <paramref name="what"/> into a file <paramref name="path"/>.
            </summary>
            <returns><c>true</c> on success, <c>false</c> if the path is invalid.</returns>
        </member>
        <member name="T:Elegy.Text.Lexer">
            <summary>
            Lexicological parser, parses tokens out of a continuous piece of text.
            Ported from adm-utils: https://github.com/Admer456/adm-utils/blob/master/src/Text/Lexer.hpp
            </summary>
            <remarks>Right now it works with <see cref="T:System.String"/>, it may be worth investigating a <see cref="T:System.ReadOnlySpan`1"/> version.</remarks>
        </member>
        <member name="M:Elegy.Text.Lexer.Clear">
            <summary>
            Clears the text buffer.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.Load(System.String)">
            <summary>
            Loads the given <paramref name="text"/>
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Elegy.Text.Lexer.SetDelimiters(System.String)">
            <summary>
            Sets new delimiters.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.Next">
            <summary>
            Continues parsing the string and extracts the next token from it.
            </summary>
            <returns>The next token in line, "" if EOF is reached.</returns>
        </member>
        <member name="M:Elegy.Text.Lexer.Peek">
            <summary>
            Peeks at the next string.
            </summary>
            <returns>The next token in line, "" if EOF is reached.</returns>
        </member>
        <member name="M:Elegy.Text.Lexer.PeekUntil(System.String,System.Boolean)">
            <summary>
            Returns all characters that were encountered between the current position
            and <paramref name="what"/>. If <paramref name="skipPeeked"/> is <c>true</c>,
            the cursor will skip the result too.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.TokensBeforeNewline">
            <summary>
            Returns a string of tokens until the newline.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.TokenListBeforeNewline">
            <summary>
            An array of tokens until the newline.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.Expect(System.String,System.Boolean)">
            <summary>
            Peeks at the next string and, optionally, advances seeking.
            </summary>
            <param name="expectedToken">The token to expect.</param>
            <param name="advanceIfTrue">Advance the seeking upon success? Behaves about the same as Next then.</param>
            <returns>true if the next token and expectedToken match.</returns>
        </member>
        <member name="M:Elegy.Text.Lexer.ExpectAnythingUntilNewline">
            <summary>
            Is there anything other than whitespaces until the newline?
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.SkipUntil(System.String,System.Boolean)">
            <summary>
            Skips characters until a given string <paramref name="what"/> has been found.
            If <paramref name="skipThatToo"/> is <c>true</c>, it'll skip that string as well.
            </summary>
            <param name="what"></param>
            <param name="skipThatToo"></param>
        </member>
        <member name="M:Elegy.Text.Lexer.IsEnd">
            <summary>
            Whether or not the end of the text has been reached.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.NewLine">
            <summary>
            Skip the current line.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.GetLineInfo">
            <summary>
            Gets the current line and column, formatted in a string.
            </summary>
        </member>
        <member name="M:Elegy.Text.Lexer.GetLineNumber">
            <summary>
            Gets the current line number.
            </summary>
        </member>
        <member name="P:Elegy.Text.Lexer.IgnoreDelimiters">
            <summary>
            Whether or not to ignore delimiters while scanning for characters.
            </summary>
        </member>
        <member name="T:Elegy.Utilities.ByteBuffer">
            <inheritdoc/>
        </member>
        <member name="P:Elegy.Utilities.ByteBuffer.Position">
            <inheritdoc/>
        </member>
        <member name="P:Elegy.Utilities.ByteBuffer.Data">
            <inheritdoc/>
        </member>
        <member name="P:Elegy.Utilities.ByteBuffer.DataSpan">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.#ctor(System.Byte[])">
            <summary>
            Initialises the byte buffer with an existing buffer of data.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.#ctor(System.Int32)">
            <summary>
            Initialises the byte buffer so it can be filled up to <paramref name="size"/> bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.Advance(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ResetPosition">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ResetData">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.Write``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.Read``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteU8(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteBool(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteChar(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteEnum``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteI16(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteU16(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteI32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteU32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteI64(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteU64(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteF16(System.Half)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteF32(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteF64(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadU8">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadBool">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadChar">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadEnum``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadI16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadU16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadI32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadU32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadI64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadU64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadF16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadF32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadF64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteObject``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadObject``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteString(System.String,System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteStringAscii(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.WriteStringUtf8(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadString(System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadStringAscii(Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBuffer.ReadStringUtf8(Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="T:Elegy.Utilities.ByteBufferDynamic">
            <summary>
            A byte buffer, implemented with an array that shrinks and grows as needed.
            </summary>
        </member>
        <member name="P:Elegy.Utilities.ByteBufferDynamic.Position">
            <inheritdoc/>
        </member>
        <member name="P:Elegy.Utilities.ByteBufferDynamic.Data">
            <inheritdoc/>
        </member>
        <member name="P:Elegy.Utilities.ByteBufferDynamic.DataSpan">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.#ctor(System.Byte[])">
            <summary>
            Initialises the byte buffer with an existing buffer of data.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.#ctor(System.Int32)">
            <summary>
            Initialises the byte buffer and reserves <paramref name="size"/> bytes as a starting point.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.Advance(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ResetPosition">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ResetData">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.Write``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.Read``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteU8(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteBool(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteChar(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteEnum``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteI16(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteU16(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteI32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteU32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteI64(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteU64(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteF16(System.Half)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteF32(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteF64(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadU8">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadBool">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadChar">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadEnum``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadI16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadU16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadI32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadU32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadI64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadU64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadF16">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadF32">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadF64">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteObject``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadObject``1">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteString(System.String,System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteStringAscii(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.WriteStringUtf8(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadString(System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadStringAscii(Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="M:Elegy.Utilities.ByteBufferDynamic.ReadStringUtf8(Elegy.Utilities.Interfaces.StringLength)">
            <inheritdoc/>
        </member>
        <member name="T:Elegy.Utilities.Interfaces.StringLength">
            <summary>
            String length options for <see cref="T:Elegy.Utilities.Interfaces.IByteBuffer"/>.
            </summary>
        </member>
        <member name="F:Elegy.Utilities.Interfaces.StringLength.Short">
            <summary>
            Up to 255 characters.
            </summary>
        </member>
        <member name="F:Elegy.Utilities.Interfaces.StringLength.Medium">
            <summary>
            Up to 65'535 characters.
            </summary>
        </member>
        <member name="F:Elegy.Utilities.Interfaces.StringLength.Long">
            <summary>
            Up to approximately 2.147 billion characters.
            </summary>
        </member>
        <member name="T:Elegy.Utilities.Interfaces.IByteBuffer">
            <summary>
            Byte buffer, a container that you can use to conveniently
            read from and write to binary blobs of data.
            </summary>
        </member>
        <member name="P:Elegy.Utilities.Interfaces.IByteBuffer.Position">
            <summary>
            Cursor position.
            </summary>
        </member>
        <member name="P:Elegy.Utilities.Interfaces.IByteBuffer.Data">
            <summary>
            Buffer data.
            </summary>
        </member>
        <member name="P:Elegy.Utilities.Interfaces.IByteBuffer.DataSpan">
            <summary>
            Span version of <see cref="P:Elegy.Utilities.Interfaces.IByteBuffer.Data"/>.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.Advance(System.Int32)">
            <summary>
            Advances the cursor <paramref name="bytes"/> number of bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ResetPosition">
            <summary>
            Resets the cursor to the beginning of the buffer.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ResetData">
            <summary>
            Clears the data buffer.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.Write``1(``0)">
            <summary>
            Writes generic data into the buffer.
            </summary>
            <typeparam name="T">The type of data that gets written.</typeparam>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.Read``1">
            <summary>
            Reads generic data from the buffer.
            </summary>
            <typeparam name="T">The type of data that gets read.</typeparam>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteU8(System.Byte)">
            <summary>
            Writes an unsigned byte value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteBool(System.Boolean)">
            <summary>
            Writes a boolean value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteChar(System.Char)">
            <summary>
            Writes an ASCII character value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteEnum``1(``0)">
            <summary>
            Writes an enum value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteI16(System.Int16)">
            <summary>
            Writes a signed short value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteU16(System.UInt16)">
            <summary>
            Writes an unsigned short value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteI32(System.Int32)">
            <summary>
            Writes a signed integer value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteU32(System.UInt32)">
            <summary>
            Writes an unsigned integer value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteI64(System.Int64)">
            <summary>
            Writes a signed long value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteU64(System.UInt64)">
            <summary>
            Writes an unsigned long value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteF16(System.Half)">
            <summary>
            Writes a half-precision float value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteF32(System.Single)">
            <summary>
            Writes a single-precision float value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteF64(System.Double)">
            <summary>
            Writes a double-precision float value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadU8">
            <summary>
            Reads an unsigned byte value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadBool">
            <summary>
            Reads a boolean value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadChar">
            <summary>
            Reads an ASCII character value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadEnum``1">
            <summary>
            Reads an enum value and advances 1 byte.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadI16">
            <summary>
            Reads a signed short value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadU16">
            <summary>
            Reads an unsigned short value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadI32">
            <summary>
            Reads a signed integer value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadU32">
            <summary>
            Reads an unsigned integer value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadI64">
            <summary>
            Reads a signed long value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadU64">
            <summary>
            Reads an unsigned long value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadF16">
            <summary>
            Reads a half-precision float value and advances 2 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadF32">
            <summary>
            Reads a single-precision float value and advances 4 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadF64">
            <summary>
            Reads a double-precision float value and advances 8 bytes.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteObject``1(``0)">
            <summary>
            Writes/serialises an object that implements <see cref="T:Elegy.Utilities.Interfaces.IByteSerialisable"/>.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadObject``1">
            <summary>
            Reads/deserialises an object that implements <see cref="T:Elegy.Utilities.Interfaces.IByteSerialisable"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Elegy.Utilities.Interfaces.IByteBuffer.WriteString(System.String,System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)" -->
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteStringAscii(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <summary>
            Writes an ASCII-encoded string.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.WriteStringUtf8(System.String,Elegy.Utilities.Interfaces.StringLength)">
            <summary>
            Writes a UTF-8-encoded string.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Elegy.Utilities.Interfaces.IByteBuffer.ReadString(System.Text.Encoding,Elegy.Utilities.Interfaces.StringLength)" -->
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadStringAscii(Elegy.Utilities.Interfaces.StringLength)">
            <summary>
            Reads an ASCII-encoded string from the buffer.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Interfaces.IByteBuffer.ReadStringUtf8(Elegy.Utilities.Interfaces.StringLength)">
            <summary>
            Reads a UTF-8-encoded string from the buffer.
            </summary>
        </member>
        <member name="T:Elegy.Utilities.Interfaces.IByteSerialisable">
            <summary>
            This type can be serialised into an array of bytes, and then
            subconsequently used in IByteBuffer.Write/ReadObject.
            </summary>
        </member>
        <member name="T:Elegy.Utilities.Parse">
            <summary>
            Numeric parsing utilities.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Parse.TryInt(System.String,System.Int32@)">
            <summary>
            Attempts to parse an integer from a string, modifying <c>result</c> upon success.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Parse.Int(System.String)">
            <summary>
            Parses an integer from a string.
            </summary>
            <param name="token">Something like "20".</param>
            <returns>A valid integer value on successful parse, 0 if the token is invalid.</returns>
        </member>
        <member name="M:Elegy.Utilities.Parse.TryFloat(System.String,System.Single@)">
            <summary>
            Attempts to parse a float from a string, modifying <c>result</c> upon success.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Parse.Float(System.String)">
            <summary>
            Parses a float from a string.
            </summary>
            <param name="token">Something like "20.05".</param>
            <returns>A valid floating-point value on successful parse, 0.0f if the token is invalid.</returns>
        </member>
        <member name="M:Elegy.Utilities.Parse.TryDate(System.String,System.DateTime@)">
            <summary>
            Attempts to parse a <see cref="T:System.DateTime"/> from a string, modifying <c>result</c> upon success.
            </summary>
        </member>
        <member name="M:Elegy.Utilities.Parse.Date(System.String)">
            <summary>
            Parses dates in dd/MM/yyyy format.
            </summary>
        </member>
    </members>
</doc>
